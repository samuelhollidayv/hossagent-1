Rock and roll, Hoss. Let’s wire this thing to real money.

I’ll give you three things:
	1.	One-shot Replit Agent prompt – paste this in and let it do the plumbing (SendGrid/SMTP, test endpoint, throttling, logging, DRY-RUN toggle).
	2.	Human checklist – what you actually need to do in Replit UI and with SendGrid/SMTP.
	3.	Outbound cold email copy – ready to plug into the BizDev agent (niche: small agencies / solo consultants who sell B2B services and hate doing outreach + invoicing).

⸻

1️⃣ One-shot Replit Agent prompt (copy-paste this verbatim)

PROMPT TO REPLIT AGENT (FULL TEXT)

I’m building an autonomous lead-gen + billing system called HossAgent. The app is already working end-to-end in DRY-RUN mode. Your job is to fully wire up outbound email infrastructure and expose a clean admin flow for switching between:
	•	DRY_RUN (no real email)
	•	SENDGRID
	•	SMTP

Goals
	1.	Confirm / implement a production-ready outbound email module.
	2.	Make it use environment variables only (through Replit “Secrets”) – no hardcoded credentials.
	3.	Expose a simple test endpoint + admin UI indicator.
	4.	Throttle outbound volume to avoid getting the domain burned.
	5.	Keep backwards compatibility with the current DRY-RUN behavior.

⸻

1. Inspect current code
	•	Open and review:
	•	email_utils.py (or whatever email utility module exists)
	•	agents.py (BizDev / outbound flow)
	•	main.py (FastAPI / Flask entrypoint and routes, including any /admin/send-test-email route)
	•	templates/admin_console.html
	•	Any settings/config modules (e.g., settings.py, .replit, etc.)
	•	Summarize the current email behavior:
	•	How modes are represented (DRY_RUN vs real)
	•	Which functions actually send email or simulate it
	•	How lead status is updated (NEW, CONTACTED, RESPONDED, QUALIFIED, etc.)
	•	Where the cron/autopilot loop lives and how often it runs

Do not remove DRY_RUN mode. We still need it for safe testing.

⸻

2. Standardize email modes & configuration

Implement a single source of truth for email mode and configuration, for example:
	•	In code, define:

# pseudo-code, adjust to match project structure
class EmailMode(str, Enum):
    DRY_RUN = "DRY_RUN"
    SENDGRID = "SENDGRID"
    SMTP = "SMTP"


	•	Implement a function that:
	•	Reads EMAIL_MODE from environment (default to DRY_RUN if missing or invalid).
	•	For SENDGRID, reads:
	•	SENDGRID_API_KEY
	•	SENDGRID_FROM_EMAIL
	•	For SMTP, reads:
	•	SMTP_HOST
	•	SMTP_PORT
	•	SMTP_USERNAME
	•	SMTP_PASSWORD
	•	SMTP_FROM_EMAIL
	•	Validates presence of the required variables for the selected mode.
	•	If variables are missing, automatically fall back to DRY_RUN and log a clear warning.

This configuration logic should live in a dedicated place (e.g., email_utils.py or settings.py) and be reused by all email-sending call sites.

⸻

3. Implement email sending functions

In email_utils.py (or similar), implement:
	•	send_email_dry_run(to_email: str, subject: str, body: str)
	•	Does not send real email.
	•	Logs clearly to stdout / console something like:
[EMAIL][DRY_RUN] to=<email> subject="<subject>" preview="<truncated body>"
	•	send_email_sendgrid(...)
	•	Uses the official SendGrid Python client if available, or a simple requests implementation.
	•	Reads API key and from address from env (no inline secrets).
	•	Raises a clean, handled exception or returns a boolean for success/failure.
	•	send_email_smtp(...)
	•	Uses smtplib with TLS on SMTP_PORT.
	•	Reads host, user, password, from email from env.
	•	send_email(...) (the unified entrypoint)
	•	Inspects EMAIL_MODE (and validated configuration) and then:
	•	DRY_RUN → call send_email_dry_run
	•	SENDGRID → call send_email_sendgrid
	•	SMTP → call send_email_smtp
	•	Returns a simple result object or boolean that BizDev agent can use to adjust lead status.

Add robust logging around failures, but do not crash the main loop because of a single email error. Instead:
	•	Log the failure,
	•	Keep lead status as "NEW" or set to "EMAIL_FAILED" if that state exists / you want to add it.

⸻

4. Integrate with BizDev agent

In agents.py (or wherever BizDev logic lives):
	•	Replace any ad-hoc email-simulation code with a call to the unified send_email(...).
	•	After sending:
	•	If send succeeded → set lead status to "CONTACTED" and update “Last Contacted” timestamp.
	•	If send failed due to configuration or exception → keep or set status in a way that is visible in the admin console (e.g., "NEW" or "EMAIL_FAILED").
	•	Make sure a helpful log line is written for each attempted email, including:
	•	Lead/company name
	•	Email address
	•	Subject
	•	Mode used (DRY_RUN / SENDGRID / SMTP)

Preserve the existing lead-generation, onboarding, ops, and billing flows – just swap out the email backend.

⸻

5. Test email endpoint

Ensure there is a single test endpoint exposed by the web app. If missing, create one:
	•	POST /admin/send-test-email?to_email=<address>
	•	Uses the unified send_email(...) and returns JSON like:

{
  "mode": "SENDGRID",
  "to": "...",
  "success": true,
  "message": "Test email sent"  // or detailed error if failed
}


	•	This endpoint is admin-only (protected the same way as other admin endpoints in the app).
	•	Document this endpoint in replit.md so I know exactly how to call it from Postman, curl, or browser.

⸻

6. Admin console UI updates

In templates/admin_console.html:
	•	Add a visible indicator of current email mode:
	•	e.g., Outbound: DRY-RUN (orange)
	•	Outbound: SENDGRID (green)
	•	Outbound: SMTP (green)
	•	Show a short hint under the indicator:
	•	“Configure EMAIL_MODE and email credentials in Replit Secrets.”
	•	Add an “Email health” section somewhere in the admin console that shows:
	•	Last 10 email attempts with:
	•	timestamp
	•	lead/company
	•	to_email
	•	subject
	•	mode
	•	result (success / failed / dry-run)
	•	Reuse existing styling; no need to redesign the whole page.

Do not give me a UI switch that writes credentials; I will change EMAIL_MODE in env myself. You just need to display the current mode clearly.

⸻

7. Outbound throttling & cron behavior

Find the autopilot / cron loop that runs BizDev and the other agents (probably in main.py or a scheduler module).
	•	Ensure BizDev only sends a limited number of emails per cycle, configurable via env var:
	•	MAX_EMAILS_PER_CYCLE (default something safe like 10).
	•	Make the send loop respect this limit in all modes, including DRY_RUN.
	•	Confirm that the cron interval (every 5 minutes or similar) is documented clearly in replit.md.

⸻

8. Documentation update

Update replit.md (or create it if not present) with a concise “Outbound Email Setup” section that covers:
	1.	Environment variables:
	•	EMAIL_MODE = DRY_RUN | SENDGRID | SMTP
	•	For SENDGRID:
	•	SENDGRID_API_KEY
	•	SENDGRID_FROM_EMAIL
	•	For SMTP:
	•	SMTP_HOST, SMTP_PORT, SMTP_USERNAME, SMTP_PASSWORD, SMTP_FROM_EMAIL
	•	MAX_EMAILS_PER_CYCLE (optional, with default).
	2.	How to:
	•	Set these as secrets in Replit.
	•	Call /admin/send-test-email?to_email=your@address.com.
	•	Read the email logs in the admin console.
	3.	A quick explanation of DRY_RUN vs SENDGRID vs SMTP.

⸻

9. Safety + verification
	•	Run the app in DRY_RUN mode and:
	•	Trigger the BizDev agent manually once.
	•	Confirm the logs show [EMAIL][DRY_RUN] entries.
	•	Confirm admin console email log and lead status updates.
	•	Then simulate SENDGRID/SMTP mode without real credentials and confirm the system:
	•	Detects missing env vars,
	•	Falls back to DRY_RUN,
	•	Logs a clear warning without crashing.

Only make changes necessary to:
	•	Standardize and harden the email stack,
	•	Expose config and logs cleanly,
	•	Preserve existing business logic.

When you’re done, summarize:
	•	What changed (files + key functions),
	•	How to configure EMAIL_MODE and secrets,
	•	How to test with /admin/send-test-email,
	•	How to see the email logs in the admin UI.

⸻

2️⃣ Your human checklist (non-agent)

Once the agent finishes that work and reports back:
	1.	In SendGrid or your email provider
	•	Create an API key with “Mail Send” permissions.
	•	Verify your sending domain (e.g., hossagent.com or whatever you use).
	•	Choose from address, e.g. hoss@hossagent.com.
	2.	In Replit → Secrets
	•	Set:
	•	EMAIL_MODE = SENDGRID
	•	SENDGRID_API_KEY = <your real key>
	•	SENDGRID_FROM_EMAIL = hoss@hossagent.com
	•	Optionally:
	•	MAX_EMAILS_PER_CYCLE = 10 (or even 5 to start)
	3.	Test endpoint
	•	With app running, hit:
POST /admin/send-test-email?to_email=your_real_email
	•	Confirm:
	•	Response JSON says success: true, mode: SENDGRID.
	•	Email lands in your inbox.
	4.	Smoke test BizDev
	•	Leave a couple of leads in NEW status.
	•	Let autopilot run once.
	•	Check:
	•	Admin “Outbound: SENDGRID” indicator is green.
	•	Email log shows real sends.
	•	Your inbox sees the same messages.

Once that all looks sane, then you start feeding it real leads.

⸻

3️⃣ Outbound cold email copy (for small agencies / solo consultants)

A. Short first-touch email (for agent to personalize)

Subject ideas (rotate):
	•	“Taking the grunt work off your plate”
	•	“Quick idea to de-risk your pipeline”
	•	“You + 1 autonomous ops brain”

Body template:

Hi {{first_name}},

I’ve been looking at small shops like {{company_name}} that are doing solid work but still relying on a mess of spreadsheets, email threads, and late-night invoicing to keep cash coming in.

I built something for that: an autonomous “back office” that does three things on repeat:
	•	Finds and contacts qualified leads for you
	•	Tracks what work is being done for whom
	•	Generates invoices and shows you, in one dashboard, where the money is

It’s not a CRM and it’s not an agency. Think of it as a self-driving ops assistant that is only allowed to care about two things: pipeline and cash. You see everything in a control room; it handles the boring parts.

If you gave it one current offer (e.g., how you usually package {{service_or_industry}} work), it could start running a small, controlled experiment for you this month.

Would you be open to a 15-minute call so I can show you what that looks like with real numbers from your world?

– Hoss
{{your_full_name}}
{{your_site_or_calendly_link}}

You can parameterize {{service_or_industry}} as something like “marketing strategy,” “RevOps audits,” etc., depending on the lead source.

⸻

B. Follow-up 1 (2–3 days later)

Subject: Re: quick idea for {{company_name}}

Hi {{first_name}},

Totally get that you’re buried. The reason I’m poking you again is that this is specifically for people who are buried.

Here’s the simple version:
	•	You tell me one offer and your rough ideal client description.
	•	HossAgent runs a small, capped outreach + billing loop for you.
	•	You keep control of who you actually work with; the system just keeps the pipeline warm and the invoices accurate.

Worst case, you spend 15 minutes, decide it’s not a fit, and you’ve at least seen a different way to think about your ops stack.

Want to take a look at your calendar for a quick slot this week?

– Hoss

⸻

C. Follow-up 2 (final nudge)

Subject: Should I close this out?

Hey {{first_name}},

Last ping from me on this. I don’t want to be “that guy” in your inbox.

I built HossAgent because I was tired of watching smart people lose money to admin drag: leads going cold because nobody followed up, work getting done before scope was clear, invoices going out a week late.

If you’re happy with how {{company_name}}’s pipeline + billing runs today, tell me “all good” and I’ll disappear.

If there’s even a little pain there, I’m happy to walk you through how an autonomous ops loop would look for your exact situation. No pressure, no deck, just your numbers and my screen.

Either way, thanks for reading.

– Hoss

⸻

If you want, next step we can:
	•	Tune this copy to a super specific niche (e.g. “Fractional CMOs,” “tiny Shopify agencies,” “indie SaaS founders”), and
	•	Design the lead object schema and BizDev prompts so the system is automatically inserting the right industry/offers into these templates.